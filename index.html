<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Happy Birthday Aafia - 3D Celebration</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
    height: 100vh;
  }
  #container {
    width: 100vw; height: 100vh; display: block;
    touch-action: none;
  }
  #loadingMessage {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: #fff; font-size: 24px; font-weight: 700;
    text-shadow: 0 0 10px #000;
  }
  #controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 14px; user-select: none;
    background: rgba(0,0,0,0.3); padding: 6px 12px; border-radius: 20px;
  }
</style>
</head>
<body>
<div id="loadingMessage">Loading 3D Birthday celebration...</div>
<div id="container"></div>
<div id="controls">Click balloons to pop üéà | Click candles to blow out üïØÔ∏è | Click cake slices to cut üç∞</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/OrbitControls.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script>
// Scene Setup
const container = document.getElementById('container');
const loadingMessage = document.getElementById('loadingMessage');
let scene, camera, renderer, controls;
let clock = new THREE.Clock();
let mixer, actions = [], activeAction;
let animationsReady = false;

init();
animate();

function init() {
  scene = new THREE.Scene();

  // Camera
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 8);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias: true, alpha: false});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x220011);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  // Controls (for desktop viewer)
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;
  controls.minDistance = 3;
  controls.maxDistance = 15;
  controls.maxPolarAngle = Math.PI / 2.2;

  // Lighting
  const ambient = new THREE.AmbientLight(0x993366, 0.6);
  scene.add(ambient);

  const directionalLight = new THREE.DirectionalLight(0xffb3b3, 0.9);
  directionalLight.position.set(5, 10, 7);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);

  // Ground plane (reflective subtle)
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshStandardMaterial({color: 0x331122, roughness: 0.7, metalness: 0.1})
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -1;
  ground.receiveShadow = true;
  scene.add(ground);

  // Load and create all objects with animations
  createBalloons();
  createCakeEnvironment();
  createFloatingText();
  createParticles();

  // Background music
  loadMusic();

  // Responsive
  window.addEventListener('resize', onWindowResize);

  // Remove loading when ready
  setTimeout(() => {
    loadingMessage.style.display = 'none';
  }, 5000); // max wait 5 sec in case manual load
}

// Resize handler
function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Animate & render loop
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  updateBalloons(dt);
  updateParticles(dt);
  updateCakeAnimations(dt);

  controls.update();
  renderer.render(scene, camera);
}

///////////////////////
// Balloons
let balloons = [];
let balloonPopParticles = [];

function createBalloons() {
  const balloonGeometry = new THREE.SphereGeometry(0.25, 32, 32);
  const balloonMaterial = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
    clearcoat: 1.0,
    clearcoatRoughness: 0.1,
    metalness: 0.3,
    roughness: 0.2,
    reflectivity: 0.6,
    transparent: true,
    opacity: 0.9
  });

  for(let i=0; i<20; i++) {
    let balloon = new THREE.Mesh(balloonGeometry, balloonMaterial.clone());
    balloon.material.color.setHSL(Math.random(), 0.8, 0.5 + Math.random()*0.2);
    balloon.position.set(
      (Math.random() - 0.5)*10,
      Math.random()*3 + 1,
      (Math.random() - 0.5)*10
    );
    balloon.castShadow = true;
    balloon.userData = { popped: false };
    scene.add(balloon);
    balloons.push(balloon);
  }

  // Interaction
  renderer.domElement.addEventListener('pointerdown', onBalloonClick);
}

function updateBalloons(dt) {
  balloons.forEach(b => {
    if (b.userData.popped) return;
    // Slight up and down with sway
    b.position.y += 0.3 * dt;
    if (b.position.y > 5) b.position.y = 1 + Math.random()*1.5;
    b.rotation.z += 0.2 * dt;
    b.rotation.x += 0.2 * dt;
  });
}

function onBalloonClick(event) {
  event.preventDefault();

  // Get mouse coords normalized
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // Raycaster to find balloons
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(balloons.filter(b => !b.userData.popped));

  if (intersects.length > 0) {
    const balloon = intersects[0].object;
    popBalloon(balloon);
  }
}

function popBalloon(balloon) {
  if(balloon.userData.popped) return;
  balloon.userData.popped = true;

  // Pop sound effect using AudioContext
  playPopSound();

  // Particle burst
  createPopParticles(balloon.position);

  // Remove balloon visually with scale down animation
  gsap.to(balloon.scale, {x:0, y:0, z:0, duration: 0.5, ease: 'power2.out', onComplete: () => {
    scene.remove(balloon);
  }});
}

// Pop sound (simple click-popping sound synthesized)
function playPopSound() {
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.type = 'triangle';
  oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
  oscillator.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.1);

  gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);

  oscillator.connect(gainNode).connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.2);
}

// Pop particle system
const popParticleGeometry = new THREE.SphereGeometry(0.03, 8, 8);
const popParticleMaterial = new THREE.MeshBasicMaterial({ color: 0xff6699 });

function createPopParticles(position) {
  for(let i=0; i<15; i++){
    let particle = new THREE.Mesh(popParticleGeometry, popParticleMaterial.clone());
    particle.position.copy(position);
    particle.userData = {
      velocity: new THREE.Vector3(
        (Math.random() - 0.5) * 3,
        (Math.random() - 0.5) * 3,
        (Math.random() - 0.5) * 3
      ),
      life: 1.0
    };
    scene.add(particle);
    balloonPopParticles.push(particle);
  }
}

function updateParticles(dt) {
  balloonPopParticles.forEach((p, idx) => {
    if(p.userData.life <= 0) {
      scene.remove(p);
      balloonPopParticles.splice(idx, 1);
      return;
    }
    // Movement and fade
    p.position.addScaledVector(p.userData.velocity, dt*3);
    p.userData.velocity.multiplyScalar(0.9);
    p.userData.life -= dt;
    p.material.opacity = p.userData.life;
    p.material.transparent = true;
  });
}

///////////////////////
// Cake Environment
let cakeGroup, candles = [], candleFlames = [], cakeSlices = [];

function createCakeEnvironment() {
  cakeGroup = new THREE.Group();
  cakeGroup.position.set(0, 0, 0);
  scene.add(cakeGroup);

  // Cake base tiers with multiple stacked cylinders
  const tierHeight = 0.5;
  const tierColors = [0xffaaaa, 0xffccd5, 0xff6688];
  const radii = [1.5, 1.0, 0.6];

  for(let i=0; i<3; i++) {
    const geometry = new THREE.CylinderGeometry(radii[i], radii[i], tierHeight, 64);
    const material = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(tierColors[i]),
      roughness: 0.4,
      metalness: 0.3,
      clearcoat: 1,
      clearcoatRoughness: 0.2,
      reflectivity: 0.8,
      transmission: 0.3
    });
    const tier = new THREE.Mesh(geometry, material);
    tier.position.y = tierHeight/2 + i*tierHeight;
    tier.castShadow = true;
    tier.receiveShadow = true;
    cakeGroup.add(tier);

    // Cake slices division - invisible interactive planes
    createCakeSlicesOnTier(tier, i, radii[i], tierHeight);
  }

  // Candles on top tier
  createCandles(12, radii[2], 1.5);

  // Glow candle flames
  createCandleFlames();

  // Add subtle smoke particles above candles
  createCandleSmoke();
}

function createCakeSlicesOnTier(tier, tierIndex, radius, height) {
  const sliceCount = 12;
  for(let i=0; i<sliceCount; i++){
    const slice = new THREE.Mesh(
      new THREE.CircleGeometry(radius, sliceCount, i * (2*Math.PI/sliceCount), (2*Math.PI/sliceCount)*0.95),
      new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.0})
    );
    slice.position.y = tier.position.y + 0.01;
    slice.rotation.x = -Math.PI / 2;
    cakeGroup.add(slice);
    cakeSlices.push({mesh: slice, tier: tierIndex, index: i, cut: false});
  }
}

// Create candles positioned in circle on top tier
function createCandles(count, radius, height) {
  const candleHeight = 0.4;
  const candleRadius = 0.05;
  const candleGeometry = new THREE.CylinderGeometry(candleRadius, candleRadius, candleHeight, 16);
  const candleMaterial = new THREE.MeshPhysicalMaterial({color: 0xffffee, roughness: 0.3, metalness: 0.1});

  for(let i=0; i<count; i++) {
    const candle = new THREE.Mesh(candleGeometry, candleMaterial.clone());
    const angle = (i / count) * 2 * Math.PI;
    candle.position.set(
      radius * Math.cos(angle),
      1.6 + candleHeight/2,
      radius * Math.sin(angle)
    );
    candle.castShadow = true;
    cakeGroup.add(candle);
    candles.push(candle);
  }
}

const flameGeometry = new THREE.ConeGeometry(0.07, 0.15, 16, true);
const flameMaterial = new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.8});

function createCandleFlames() {
  candles.forEach(candle => {
    const flame = new THREE.Mesh(flameGeometry, flameMaterial.clone());
    flame.position.set(0, 0.25, 0);
    flame.rotation.x = Math.PI;
    candle.add(flame);
    candleFlames.push(flame);
  });
}

// Candle smoke particles
let smokeParticles = [];
function createCandleSmoke() {
  const smokeGeometry = new THREE.SphereGeometry(0.02, 8, 8);
  for(let i=0; i<12; i++){
    let smoke = new THREE.Mesh(smokeGeometry, new THREE.MeshBasicMaterial({
      color: 0xdddddd,
      transparent: true,
      opacity: 0.3
    }));
    smoke.position.set(
      0.06 * (Math.random()-0.5),
      0.4,
      0.06 * (Math.random()-0.5)
    );
    smoke.userData = { velocity: new THREE.Vector3(0, 0.02 + Math.random()*0.015, 0), life: 1 };
    candles[i].add(smoke);
    smokeParticles.push(smoke);
  }
}

function updateCakeAnimations(dt) {
  // Flicker candle flames alpha
  candleFlames.forEach(flame => {
    flame.material.opacity = 0.6 + 0.3 * Math.sin(clock.elapsedTime * 20 + flame.id);
  });

  // Move smoke upwards and fade out, recycle position
  smokeParticles.forEach(smoke => {
    smoke.position.y += smoke.userData.velocity.y;
    smoke.material.opacity -= 0.005;
    if(smoke.material.opacity <= 0) {
      smoke.material.opacity = 0.3;
      smoke.position.y = 0.4;
    }
  });
}

// Cake cutting interaction
renderer.domElement.addEventListener('pointerdown', onCakeSliceClick);

function onCakeSliceClick(event) {
  event.preventDefault();

  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(cakeSlices.filter(slice => !slice.cut).map(slice => slice.mesh));

  if(intersects.length > 0){
    const sliceMesh = intersects[0].object;
    const sliceData = cakeSlices.find(s => s.mesh === sliceMesh);
    if(sliceData && !sliceData.cut){
      cutCakeSlice(sliceData);
    }
  }
}

function cutCakeSlice(sliceData) {
  sliceData.cut = true;
  // Visual slice cut animation - make slice slightly lift and rotate
  gsap.to(sliceData.mesh.position, {y: 0.3, duration: 0.5, ease:'power2.out'});
  gsap.to(sliceData.mesh.rotation, {z: Math.PI/4, duration: 0.7, ease:'power2.out'});
  gsap.to(sliceData.mesh.material, {opacity: 0.5, duration: 1, ease:'power2.out'});

  // Cake cutting sound effect (simple beep)
  playCutSound();

  // Confetti burst on cut
  createConfetti(sliceData.mesh.position);
}

// Simple cutting sound - short beep
function playCutSound() {
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.setValueAtTime(600, audioCtx.currentTime);
  g.gain.setValueAtTime(0.2, audioCtx.currentTime);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + 0.1);
}

///////////////////////
// Particle Confetti for cake cutting
let confettiParticles = [];
const confettiColors = [0xff69b4, 0xffd700, 0x00ffff, 0xff4500, 0xffffff];
const confettiGeometry = new THREE.PlaneGeometry(0.1,0.05);

function createConfetti(position) {
  for(let i=0; i<30; i++) {
    const color = confettiColors[Math.floor(Math.random()*confettiColors.length)];
    const material = new THREE.MeshBasicMaterial({color, side: THREE.DoubleSide});
    const confetti = new THREE.Mesh(confettiGeometry, material);
    confetti.position.copy(position);
    confetti.position.x += (Math.random()-0.5);
    confetti.position.z += (Math.random()-0.5);
    confetti.position.y += 0.5;
    confetti.rotation.x = Math.random() * Math.PI;
    confetti.rotation.y = Math.random() * Math.PI;
    confetti.userData = {
      velocity: new THREE.Vector3(
        (Math.random()-0.5)*2,
        1 + Math.random()*2,
        (Math.random()-0.5)*2
      ),
      rotationSpeed: new THREE.Vector3(
        Math.random()*5,
        Math.random()*5,
        Math.random()*5
      ),
      life: 2.0
    };
    scene.add(confetti);
    confettiParticles.push(confetti);
  }
}

function updateParticles(dt) {
  // Update balloon pop particles
  balloonPopParticles.forEach((p, idx) => {
    if(p.userData.life <= 0) {
      scene.remove(p);
      balloonPopParticles.splice(idx, 1);
      return;
    }
    p.position.addScaledVector(p.userData.velocity, dt*3);
    p.userData.velocity.multiplyScalar(0.9);
    p.userData.life -= dt;
    p.material.opacity = p.userData.life;
    p.material.transparent = true;
  });

  // Update confetti particles
  confettiParticles.forEach((p, idx) => {
    if(p.userData.life <= 0) {
      scene.remove(p);
      confettiParticles.splice(idx, 1);
      return;
    }
    p.position.addScaledVector(p.userData.velocity, dt);
    p.userData.velocity.y -= 9.8 * dt * 0.3; // gravity
    p.rotation.x += p.userData.rotationSpeed.x * dt;
    p.rotation.y += p.userData.rotationSpeed.y * dt;
    p.rotation.z += p.userData.rotationSpeed.z * dt;
    p.userData.life -= dt;
    p.material.opacity = p.userData.life / 2.0;
    p.material.transparent = true;
  });
}

///////////////////////
// Floating birthday text for Aafia

let textMeshes = [];

function createFloatingText() {
  // Use CanvasTexture for text
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'transparent';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.font = "bold 64px 'Segoe UI', Tahoma";
  ctx.fillStyle = '#ff77aa';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#ffaacc';
  ctx.shadowBlur = 15;
  ctx.fillText("Happy Birthday Aafia!", canvas.width/2, 100);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });

  const sprite = new THREE.Sprite(material);
  sprite.position.set(0, 4, 0);
  sprite.scale.set(6, 1.5, 1);
  scene.add(sprite);
  textMeshes.push(sprite);

  // Animate pulse
  gsap.to(sprite.scale, {x: 7, y:1.7, duration: 1.2, ease: "power1.inOut", yoyo:true, repeat:-1});
  gsap.to(sprite.material, {opacity: 0.8, duration: 1.2, ease: "power1.inOut", yoyo:true, repeat:-1});
}

///////////////////////
// Background music
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let bgAudio, bgGain;

function loadMusic() {
  // Simple looped background melody generated with Web Audio API synth style
  bgGain = audioCtx.createGain();
  bgGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
  bgGain.connect(audioCtx.destination);

  // Play notes sequentially
  let startTime = audioCtx.currentTime;
  const melody = [
    { frequency: 440, duration: 0.6 }, // A4
    { frequency: 494, duration: 0.6 }, // B4
    { frequency: 523, duration: 0.6 }, // C5
    { frequency: 587, duration: 0.6 }, // D5
    { frequency: 659, duration: 0.6 }, // E5
    { frequency: 698, duration: 0.6 }, // F5
    { frequency: 784, duration: 0.6 }  // G5
  ];

  function playNote(freq, time, dur) {
    const osc = audioCtx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, time);
    const gainNode = audioCtx.createGain();
    gainNode.gain.setValueAtTime(0, time);
    gainNode.gain.linearRampToValueAtTime(0.2, time + 0.05);
    gainNode.gain.linearRampToValueAtTime(0, time + dur);
    osc.connect(gainNode).connect(bgGain);
    osc.start(time);
    osc.stop(time + dur);
  }

  function playMelody() {
    let time = audioCtx.currentTime + 0.1;
    melody.forEach(note => {
      playNote(note.frequency, time, note.duration);
      time += note.duration;
    });
    // Repeat melody
    setTimeout(playMelody, melody.reduce((acc, n) => acc+n.duration, 0)*1000);
  }

  // Start after user interaction per browser autoplay policy
  document.body.addEventListener('click', function startMusic() {
    if(audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    playMelody();
    document.body.removeEventListener('click', startMusic);
  });
}

</script>

</body>
</html>
